
<!DOCTYPE html>
<html lang="en">


<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">
  <meta name="theme-color" content="#202020"/>
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>
  
  
    <meta name="keywords" content="rmi," />
  

  
    <meta name="description" content="深入学习rmi工作原理" />
  
  
  <link rel="icon" type="image/x-icon" href="/logo.png">
  <title>深入学习rmi工作原理 [ las ]</title>
  
    <!-- stylesheets list from config.yml -->
    
      <link rel="stylesheet" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css">
    
      <link rel="stylesheet" href="/css/xoxo.css">
    
  
<meta name="generator" content="Hexo 5.2.0"></head>


<body>
  <div class="nav-container">
    <nav class="home-menu pure-menu pure-menu-horizontal">
  <a class="pure-menu-heading" href="/">
    <img class="avatar" src="http://last-las.github.io/images/logo.png">
    <span class="title">las</span>
  </a>

  <ul class="pure-menu-list clearfix">
      
          
            <li class="pure-menu-item"><a href="/" class="pure-menu-link">Home</a></li>
          
      
          
            <li class="pure-menu-item"><a href="/archives" class="pure-menu-link">Archives</a></li>
          
      
          
            <li class="pure-menu-item"><a href="/tags" class="pure-menu-link">Tags</a></li>
          
      
          
            <li class="pure-menu-item"><a href="/categories" class="pure-menu-link">Categories</a></li>
          
      
          
            <li class="pure-menu-item"><a href="/about" class="pure-menu-link">About</a></li>
          
      
  </ul>
   
</nav>
  </div>

  <div class="container" id="content-outer">
    <div class="inner" id="content-inner">
      <div class="post-container">
  <article class="post" id="post">
    <header class="post-header text-center">
      <h1 class="title">
        深入学习rmi工作原理
      </h1>
      <span>
        
        <time class="time" datetime="2020-12-10T00:53:46.000Z">
        2020-12-10
      </time>
        
      </span>
      <span class="slash">/</span>
      <span class="post-meta">
      <span class="post-tags">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/rmi/" rel="tag">rmi</a></li></ul>
      </span>
    </span>
    </header>

    <div class="post-content">
      <h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>随着对rmi反序列化的深入学习，发现它的攻击面并没有一开始理解的浅显。主要还是在看这篇<a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/7930">针对RMI服务的九重攻击</a>时，发现攻击中涉及的类和通信协议足以让我单独花上时间研究一阵子了。因此这篇算是我单独研究rmi调用流程和源码的总结。</p>
<h2 id="2-回顾"><a href="#2-回顾" class="headerlink" title="2. 回顾"></a>2. 回顾</h2><p>先回顾一下rmi工作的流程：</p>
<ol>
<li>注册端开启注册服务</li>
<li>服务端在注册端通过<code>String - Object</code>的映射关系绑定对象</li>
<li>客户端通过一个字符串向注册端查询获取到操纵远程对象的stub(?)</li>
<li>客户端通过stub来执行远程方法</li>
</ol>
<p>在整个流程中，涉及了两组关系：</p>
<ul>
<li>客户端——注册端</li>
<li>客户端——服务端</li>
</ul>
<p>这里的两个客户端都是相对而言的，并不是指代同一个对象。比如，注册端开放在<code>192.168.242.1:1099</code>端口，下述代码的行为就是我说的第一个客户端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Registry registry = LocateRegistry.getRegistry(<span class="string">&quot;192.168.242.1&quot;</span>, <span class="number">1099</span>);</span><br><span class="line">String[] lists = registry.list();</span><br><span class="line">registry.lookup(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">registry.bind(<span class="string">&quot;las&quot;</span>, <span class="keyword">new</span> myRemoteObj());  <span class="comment">// only work for localhost</span></span><br></pre></td></tr></table></figure>

<p>再比如，当通过lookup方法获取到一个对象后，对该对象的操作就是指代第二种实体关系：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">myInterface obj = registry.lookup(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">obj.myMethod(<span class="string">&quot;param&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>上面两种实体之间的通讯细节和协议，就是我接下来要尝试解释的东西。</p>
<p>由于分析rmi源码也是为了能够更深入的学习rmi安全问题，所以我列出了分析中的一些关注点以助于理解：</p>
<ul>
<li>当服务端要抛出一个错误时，它的调用栈是怎样的。这个错误是怎样被发送给客户端的。</li>
<li>客户端的<code>DGCClient</code>对象发起<code>dirty call</code>的流程。这里实际上就是ysoserial中<strong>JRMPClient</strong>载荷利用的地方。</li>
<li><code>UnicastServerRef#dispatch</code>方法的两个分支。</li>
</ul>
<h2 id="3-客户端—注册端"><a href="#3-客户端—注册端" class="headerlink" title="3. 客户端—注册端"></a>3. 客户端—注册端</h2><h3 id="注册端"><a href="#注册端" class="headerlink" title="注册端"></a>注册端</h3><p>简单来说，注册端监听在1099端口，解析客户端发起的所有连接，判断它们是<code>list</code>、<code>bind</code>、<code>rebind</code>、<code>lookup</code>、<code>unbind</code>这五种行为的哪一种，并调用相应的方法来处理。不过在此之前，它们还会传递一些数据包用于认证和信息交换。比如，下面是客户端在执行<code>lookup</code>方法时所产生的流量：</p>
<p><img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201207111641927.png" alt="image-20201207111641927"></p>
<p>不过注册端不只会处理这些api调用，后面会看到，注册端还会处理<code>dgc</code>和一些心跳包的发送。</p>
<p>分析清楚了注册端的行为，就能搞清楚客户端所做的事情，两者是相对的。</p>
<hr>
<p>我们首先分析注册端。</p>
<p>一般来说，注册端的关键代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IRemoteHelloWorld remoteHelloWorld = <span class="keyword">new</span> RemoteHelloWorldImpl();</span><br><span class="line">Registry registry = LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">registry.bind(<span class="string">&quot;Hello&quot;</span>, remoteHelloWorld);</span><br></pre></td></tr></table></figure>

<h4 id="处理网络数据前的调用链"><a href="#处理网络数据前的调用链" class="headerlink" title="处理网络数据前的调用链"></a>处理网络数据前的调用链</h4><p>进入<code>createRegistry</code>方法：</p>
<p><img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201207112224962.png" alt="image-20201207112224962"></p>
<blockquote>
<p>这里获取到的是一个<code>RegistryImpl</code>对象。需要说明的是，客户端一般调用的是<code>LocateRegistry.getRegsitry(ip,port)</code>，它获取到的是一个<code>RegistryImpl_Stub</code>对象。故可知，stub和skel的概念是相对而言的，并不只存在于<strong>服务端和客户端</strong>之间。</p>
</blockquote>
<p>进入<code>RegistryImpl</code>的构造方法：</p>
<p><img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201207112607664.png" alt="image-20201207112607664"></p>
<p>可以看到，无论是if还是else语句块中，核心代码都是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LiveRef var2 = <span class="keyword">new</span> LiveRef(id, var1);</span><br><span class="line"><span class="keyword">this</span>.setup(<span class="keyword">new</span> UnicastServerRef(var2));</span><br></pre></td></tr></table></figure>

<p>这里之所以有个if，是为了保证当程序设置了<code>SecurityManager</code>后，只有当rmi注册服务开放在1099端口时才能执行核心代码。在设置<code>SecurityManager</code>策略后，程序本身可能会没有特权去执行核心代码，因此需要通过<code>AccessController.doPrivileged</code>的形式去赋予特权。关于AccessController可参见<a target="_blank" rel="noopener" href="http://www.blogjava.net/DLevin/archive/2016/07/18/390637.html">连接</a>。</p>
<p>总的来说，这里的if相当于提供了一个安全策略：程序员可以通过设置<code>securityManager</code>来保证rmi服务只能开放在1099端口。</p>
<p>接下来进入<code>this.setup()</code>方法：</p>
<p><img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201207160942634.png" alt="image-20201207160942634"></p>
<p>这里执行了<code>UnicastServerRef</code>上的<code>exportObject</code>方法，这也是第一次看到<code>exportObject</code>方法出现。执行了它之后，客户端就可以调用注册端上的api了，就好像注册端（object）被暴露（export）在了1099端口一样。</p>
<p>在openjdk代码的注释中解释的则更detail：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Export this object, create the skeleton and stubs for this</span></span><br><span class="line"><span class="comment">    * dispatcher.  Create a stub based on the type of the impl,</span></span><br><span class="line"><span class="comment">    * initialize it with the appropriate remote reference. Create the</span></span><br><span class="line"><span class="comment">    * target defined by the impl, dispatcher (this) and stub.</span></span><br><span class="line"><span class="comment">    * Export that target via the Ref.</span></span><br><span class="line"><span class="comment">    */</span></span><br></pre></td></tr></table></figure>

<p>说明在这个方法里，会创建注册端相应的<code>stub</code>对象和<code>skeleton</code>对象。</p>
<p>继续跟进：</p>
<p><img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201207162916279.png" alt="image-20201207162916279"></p>
<p>这里先跟进<code>Util.createProxy()</code>方法：</p>
<p><img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201207163904134.png" alt="image-20201207163904134"></p>
<p>发现最后执行了<code>createStub</code>方法，这个方法通过反射实例化了<code>sun.rmi.registryImpl_Stub</code>对象并将其作为返回值。</p>
<p>这里就知道了，<code>var5</code>就是一个<code>registryImpl_Stub</code>对象。</p>
<p>同时这里也调用了<code>this.setSkeleton</code>来设置一个<code>registryImpl_Skel</code>：</p>
<img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201208092227705.png" alt="image-20201208092227705" style="zoom:67%;" />

<p>接下来回到刚刚的<code>exportObject</code>方法中，发现它创建了一个<code>Target</code>对象<code>var6</code>，然后调用了<code>this.ref.exportObject(var6)</code>，这里的<code>ref</code>，就是我们前面创建<code>UnicastServerRef</code>时传入的<code>liveRef</code>对象：</p>
<p><img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201207164512109.png" alt="image-20201207164512109"></p>
<p>于是跟进<code>liveRef#exportObject()</code>方法：</p>
<p><img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201207164706553.png" alt="image-20201207164706553"></p>
<p>跟进：</p>
<img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201207164706553.png" style="zoom:67%;" />

<p>继续跟进：</p>
<img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201207164801827.png" alt="image-20201207164801827" style="zoom:80%;" />

<p>这里的<code>this.listen()</code>方法是重点，执行它之后注册端就开始监听1099端口了。于是我们跟进看它的内部逻辑：</p>
<p><img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201207165025776.png" alt="image-20201207165025776"></p>
<p>这里会进入到第一个if代码块内。</p>
<p>可以看到这里又出现了<code>AccessController.doPrivileged()</code>方法。由于它最终会调用到<code>TCPTransport.AcceptLoop#run</code>方法，我们直接在这个方法下断点并跟进：</p>
<img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201207165429142.png" alt="image-20201207165429142" style="zoom:80%;" />

<p>跟进：</p>
<p><img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201207170259792.png" alt="image-20201207170259792"></p>
<p>下面的代码都是<code>catch</code>块就不贴出来了。</p>
<p>这里的<code>this.serverSocket</code>就是在<code>TCPTransport#listen</code>方法中创建的，它监听的端口就是我们最开始传入的port。</p>
<p>接下来进入try中的代码块，它其实又创建了新线程。跟进<code>ConnectionHandler#run</code>方法：</p>
<p><img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201207171013163.png" alt="image-20201207171013163"></p>
<p>再跟进<code>this.run0()</code>方法。</p>
<h4 id="处理网络数据"><a href="#处理网络数据" class="headerlink" title="处理网络数据"></a>处理网络数据</h4><p>需要说明的是，从这个方法开始，就能看到注册端开始读取并解析客户端传递的TCP数据，根据字段的类型来执行相应的<code>bind</code>、<code>list</code>等操作，并将结果返回。</p>
<p>由于该方法比较长，所以我逐段进行分析。</p>
<p>前面的一些代码主要是设置TCP的一些参数，不管，看下面的部分：</p>
<p><img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201207172250302.png" alt="image-20201207172250302"></p>
<p>这里是第一次从输入流读取数据，接下来会根据<code>var6</code>的值判断进入哪个if块：</p>
<p><img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201207172527613.png" alt="image-20201207172527613"></p>
<p>这里的<strong>1347375956</strong>转为十六进制再转为字符串就是：<strong>POST</strong>。说明这里的逻辑是判断它是否为http流量，一般不会进入这个分支。</p>
<p>我们进入第二个if。<strong>1246907721</strong>转为十六进制其实是<strong>0x4a524d49</strong>，这其实就是rmi协议的魔术头，同时第二个short字段表示版本：</p>
<img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201207173120335.png" alt="image-20201207173120335" style="zoom:67%;" />

<p>在这个if分支里又读取了一个字节存到<code>var15</code>，然后进入<code>switch</code>。这里一般来说读取到的是0x4b，即75：</p>
<p><img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201208080748076.png" alt="image-20201208080748076"></p>
<p>进入case后，由于已经解析完了第一个接受包，注册端开始构造第一个回复包：</p>
<img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201208080926745.png" alt="image-20201208080926745" style="zoom:67%;" />

<p>直到<code>var10.flush();</code>，注册端缓冲区的数据被发送出去。</p>
<p>接下来的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String var16 = var5.readUTF();</span><br><span class="line"><span class="keyword">int</span> var17 = var5.readInt();</span><br></pre></td></tr></table></figure>

<p>用于解析客户端发送的第二个数据包，不过这个数据包似乎没起到什么作用。第二个数据包内容如下：</p>
<img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201208081453427.png" alt="image-20201208081453427" style="zoom:67%;" />

<p>接下来进入<code>TCPTransport.this.handleMessages(var14, true)</code>。注意第二个参数为true，它让接下来的代码中的while语句不断循环。见红框圈处：</p>
<img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201208082210301.png" alt="image-20201208082210301" style="zoom:67%;" />

<p>这里<code>int var5 = var4.read()</code>其实已经开始解析客户端发送的第三个数据包了（说明注册端并没有回复第二个数据包，从流量图也能看出），第三个数据包的内容将在之后贴出。初看这个var5是int仿佛是读取4个字节，但是跟进<code>var4.read()</code>能看到其实还是读取的一个字节：</p>
<img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201208082526068.png" alt="image-20201208082526068" style="zoom:67%;" />

<p><code>var5</code>的内容其实是表示该数据包是哪种类型。一般来说有下面三种：</p>
<ul>
<li><p>80，即<code>0x50</code>，表示执行业务方法。这里是调用注册端的某个方法（如<code>list</code>、<code>bind</code>），后面会看到，客户端在执行远程方法时，服务端也会从这里进去。</p>
<p>例如下述数据包：</p>
<p><img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201208083019016.png" alt="image-20201208083019016"></p>
</li>
<li><p>82，即<code>0x52</code>，心跳包（大概），这里可以看到注册端回复了一个字节<code>0x53</code>。例如下面两个数据包：</p>
<img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201208083304643.png" alt="image-20201208083304643" style="zoom:67%;" />
</li>
<li><p>84，即<code>0x54</code>，<code>DgcAck</code>，如下：</p>
<img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201208083430527.png" alt="image-20201208083430527" style="zoom:67%;" />



</li>
</ul>
<p>这里继续跟进80，也就是调用注册端api方法的case。进入<code>StreamRemoteCall#serviceCall</code>：</p>
<p><img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201208084115299.png" alt="image-20201208084115299"></p>
<p>我们首先贴出第三个数据包的内容：</p>
<img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201208090333948.png" alt="image-20201208090333948" style="zoom:67%;" />

<p>需要注意的是，我们上面已经读取了一个字节了，接下来的<code>aced</code>之后的内容，按理来说都是序列化的内容了。</p>
<p>但是注意这里的<code>var39 = ObjID.read(var1.getInputStream());</code>，它是从什么地方读取的内容呢？</p>
<p>其实内容是在序列化数据的<code>BlockData</code>块。</p>
<p>读取了<code>ObjID</code>后，又开启了新线程。进入<code>var6.dispatch()</code>，也就是<code>UnicastServerRef#dispatch</code>：</p>
<img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201208091534418.png" alt="image-20201208091534418" style="zoom:67%;" />

<p>这里其实是进入<code>this.oldDispatch</code>。继续跟进：</p>
<blockquote>
<p>后面在分析<strong>客户端—服务端</strong>时可知，如果不进入这个if语句，之后所作的事情其实就是服务端处理客户端调用远程对象方法的部分。这里留个印象就好。</p>
</blockquote>
<img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201208091939923.png" alt="image-20201208091939923" style="zoom:67%;" />

<p>这里的<code>this.skel</code>就是在之前调用<code>UnicastServerRef#exportObject</code>方法时设置的<code>registryImpl_Skel</code>。跟进<code>registryImpl_Skel#dispatch</code>：</p>
<p><img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201208092737894.png" alt="image-20201208092737894"></p>
<p>终于到这里了！这里就是注册端最后调用各个api（<code>list</code>、<code>bind</code>等）的地方。</p>
<p>看一眼堆栈：</p>
<img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201208093130661.png" alt="image-20201208093130661" style="zoom:50%;" />

<p>不过到这里，我们只跟进了<code>LocateRegistry.createRegistry</code>的内容。注册端的代码还有一条：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">registry.bind(<span class="string">&quot;Hello&quot;</span>, remoteHelloWorld);</span><br></pre></td></tr></table></figure>

<p>万幸是<code>registryImpl#bind</code>的逻辑很简单：</p>
<p><img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201208093758689.png" alt="image-20201208093758689"></p>
<p>这里只是将<strong>String——obj</strong>的映射关系放到了<code>registryImpl</code>的<code>bindings</code>中。</p>
<p>后续可以看到，客户端执行<code>lookup</code>方法时，注册端就会从<code>registryImpl</code>的<code>bindings</code>中查询对象：</p>
<img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201208152016264.png" alt="image-20201208152016264" style="zoom:67%;" />

<p>注册端分析完毕。接下来分析客户端。</p>
<h4 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h4><p>注册端调用<code>LocateRegistry#createRegistry</code>的流程比较复杂，所以截了下图便于更直观的看到调用关系。</p>
<p>每一个线程单独为一张图。</p>
<p>主线程：</p>
<p><img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201210101912120.png" alt="image-20201210101912120"></p>
<p>线程一：</p>
<p><img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201210102251601.png" alt="image-20201210102251601"></p>
<p>线程二：</p>
<img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201210103450949.png" alt="image-20201210103450949" style="zoom:67%;" />

<p>线程三，从这里开始处理网络数据：</p>
<p><img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201210105520545.png" alt="image-20201210105520545"></p>
<p>线程四，又回到了<code>UnicastServerRef</code>方法，最终调用了<code>RegistryImpl_Skel#dispatch</code>：</p>
<p><img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201210110828017.png"></p>
<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>客户端代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Registry registry = LocateRegistry.getRegistry(<span class="string">&quot;192.168.242.1&quot;</span>, <span class="number">1099</span>);</span><br><span class="line">registry.lookup(<span class="string">&quot;Hello&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>开启注册端后开始debug。</p>
<p>首先跟进<code>LocateRegistry#getRegistry</code>方法：</p>
<p><img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201208100416307.png" alt="image-20201208100416307"></p>
<p>继续跟进：</p>
<img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201208100619223.png" alt="image-20201208100619223" style="zoom:67%;" />

<p>最后同样调用<code>Util#createProxy</code>创建了一个<code>registryImpl_Stub</code>对象（这个方法在注册端的<code>UnicastServerRef#exportObject</code>中曾被调用）。传入的<code>UnicastRef</code>中包含了<code>ObjID</code>、<code>host</code>、<code>port</code>等信息，用于连接注册端：</p>
<img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201208100842415.png" alt="image-20201208100842415" style="zoom:67%;" />

<p>到这里可知，客户端调用<code>LocateRegistry#getRegistry</code>方法获取到的对象是<code>RegistryImpl_Stub</code>。</p>
<hr>
<p>接下来跟进客户端的第二行代码，即<code>RegistryImpl_Stub#lookup</code>：</p>
<img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201208101737202.png" alt="image-20201208101737202" style="zoom:67%;" />

<p>在<code>super.ref.newCall( this, operations, 2, ...);</code>处会发起前期的握手包（不是tcp的），</p>
<p>然后在<code>super.ref.invoke(var2);</code>处发送<code>lookup</code>的数据。</p>
<p>在接下来的<code>var23=(Remote)var6.readObject()</code>获取到服务端发送的代理对象。</p>
<p>这里的<code>super.ref</code>就是一个<code>unicastRef</code>对象。</p>
<h4 id="super-ref-newCall"><a href="#super-ref-newCall" class="headerlink" title="super.ref.newCall()"></a>super.ref.newCall()</h4><p>这里先跟进<code>super.ref.newCall</code>：</p>
<img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201208103253013.png" alt="image-20201208103253013" style="zoom:67%;" />

<p>再跟进<code>this.ref.getChannel().newConnection()</code>，AKA<code>TCPChannel#newConnection</code>：</p>
<img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201208103642815.png" alt="image-20201208103642815" style="zoom:67%;" />

<p>跟进<code>this.createConnection()</code>，这部分代码有些长，分两部分列出：</p>
<img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201208103958627.png" alt="image-20201208103958627" style="zoom:67%;" />

<p>这里的<code>var3.writeByte(75)</code>就是去构造了客户端发送的第一个握手包，在注册端的分析中我们知道它其实表示<code>StreamProtocol</code>：</p>
<img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201207173120335.png" alt="image-20201207173120335" style="zoom:67%;" />

<p>至于if块中的<code>var3.writeByte(76)</code>，应该是在socket不是Reusable时，采用将握手包和实际数据合在一起的方式（可以看到它没有<code>var3.flush()</code>）。</p>
<p>接着<code>var3.writeByte(75)</code>看它之后的代码：</p>
<img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201208110030701.png" alt="image-20201208110030701" style="zoom:67%;" />

<p>这里是在读取注册端回复的第一个数据包。长这样，发现它把我们的host和port又发给了我们：</p>
<img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201208110240883.png" alt="image-20201208110240883" style="zoom:67%;" />

<p>从<code>var3.writeUTF</code>开始，客户端发送第二个数据包：</p>
<img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201208110432640.png" alt="image-20201208110432640" style="zoom:67%;" />

<p>到这里为止，客户端发送了两次数据包，处理了注册端的第一个回复。</p>
<p>回到<code>super.ref.newCall</code>：</p>
<img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201208103253013.png" alt="image-20201208103253013" style="zoom:67%;" />

<p>接下来进入<code>var7 = new StreamRemoteCall(var6, this.ref.getObjID(), var3, var4);</code>：</p>
<img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201208111238780.png" alt="image-20201208111238780" style="zoom:70%;" />

<p>这里其实是在构造实际的<code>lookup</code>包了。但是还没有写入对象，只是将一些信息写到了BlockData中。</p>
<img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201208111516325.png" alt="image-20201208111516325" style="zoom:50%;" />

<p>到这里为止，<code>super.ref.newCall()</code>的功能基本分析完毕。该回到<code>RegistryImpl_Stub#lookup</code>分析下个方法<code>super.ref.invoke</code>。在此之前，需要看到，在<code>lookup</code>中，它先调用了<code>var3.writeObject(var1)</code>将查询的字符串写入了缓冲区：</p>
<img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201208101737202.png" alt="image-20201208101737202" style="zoom:67%;" />



<h4 id="super-ref-invoke"><a href="#super-ref-invoke" class="headerlink" title="super.ref.invoke()"></a>super.ref.invoke()</h4><p>跟进<code>UnicastRef#invoke</code>：</p>
<img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201208112703983.png" alt="image-20201208112703983" style="zoom:70%;" />

<p>跟进<code>StreamRemoteCall#executeCall()</code>：</p>
<img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201208112902783.png" alt="image-20201208112902783" style="zoom:67%;" />

<p>首先在<code>this.releaseOutputStream()</code>中将刚才的写的数据（主要是lookup的字符串）发送了出去：</p>
<img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201208113419262.png" alt="image-20201208113419262" style="zoom:50%;" />

<p>到这里，客户端发送了第三个数据包。</p>
<p>客户端发送这个数据包之后，是期望得到注册端的回复的，因为我们希望通过<code>lookup</code>获取到一个对象，然后基于这个对象来操纵远程对象。</p>
<p>我们看一下回复数据包长啥样：</p>
<img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201208113523229.png" alt="image-20201208113523229" style="zoom:67%;" />

<p>不太清晰，用<code>SerializationDumper.jar</code>打开看下：</p>
<p><img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201208143312336.png" alt="image-20201208143312336"></p>
<p>可以看到，返回的对象是一个继承了<code>java.rmi.Remote</code>和<code>org.las.remote.IRemoteHelloWorld</code>（自定义）接口的代理对象（<code>TC_PROXYCLASSDESC</code>），同时也需要注意，在<code>TC_BLOCKDATA</code>中也有东西。后面读的一些内容就是从这里拿的。</p>
<p>接着<code>releaseOutputStream</code>的代码就开始对注册端回复的这个数据包进行处理。</p>
<p>首先验证了第一个字节是否为<code>0x51</code>，接着是读取存储在BlockData中的一个字节和UID。</p>
<blockquote>
<p>这里我们回过头看一下注册端最后<code>RegistryImpl_skel#dispatch</code>的部分，因为我们其实并没有分析它在调用了api函数后是怎样发送数据包的。我们就以<code>lookup</code>为例：</p>
<img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201208144723158.png" alt="image-20201208144723158" style="zoom:67%;" />

<p>首先关注这个<code>var2.getResultStream(true)</code>，在这个函数里会写入两个字节和UID。</p>
<img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201208144810035.png" alt="image-20201208144810035" style="zoom:50%;" />

<p>接下来将lookup查询到的<code>var8</code>写入流中。</p>
<p>然后回到调用<code>RegistryImpl_skel#dispatch</code>的上级方法<code>UnicastServerRef#oldDispatch</code>：</p>
<img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201208145218676.png" alt="image-20201208145218676" style="zoom:50%;" />

<p>这里调用<code>releaseInputStream</code>发送了缓冲的数据。</p>
</blockquote>
<p>刚才分析到<code>StreamRemoteCall#executeCall</code>读取了BLOCK_DATA中的数据，但还没有读取关键的代理对象，继续看该方法的代码：</p>
<img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201208145455343.png" alt="image-20201208145455343" style="zoom:67%;" />

<p>这里之前读到的<code>var1</code>其实是1，所以我们<code>return</code>到上一级。不过也能从这里看到，当读到的<code>var2</code>是2时，是会在这里抛出异常的。</p>
<h4 id="var6-readObject"><a href="#var6-readObject" class="headerlink" title="var6.readObject()"></a>var6.readObject()</h4><p>重新回到<code>RegistryImpl_Stub#lookup</code>，这里通过了<code>var23 = (Remote)var6.readObject()</code>来获取到<code>lookup</code>查询到的代理对象。</p>
<p>最后把这个<code>var23</code>返回，这就是<code>lookup</code>的全过程了：</p>
<img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201208150443624.png" alt="image-20201208150443624" style="zoom:50%;" />

<p>至于finally中的<code>super.ref.done</code>大致就是将刚才的流释放的操作。</p>
<p>此时的堆栈很简洁：</p>
<img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201208152118483.png" alt="image-20201208152118483" style="zoom:67%;" />



<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>以客户端定位到注册端并调用<code>lookup</code>为例，客户端与注册端的通信流程如下：<ul>
<li>客户端发送第一个握手包，注册端回复；</li>
<li>客户端发送第二个包含ip和端口的包，注册端并不回复；</li>
<li>客户端发送<code>lookup</code>数据包，其内容是字符串的序列化。注册端返回一个序列化的代理对象。</li>
</ul>
</li>
<li>注册端底层使用<code>UnicastServerRef</code>对象发送请求。与之相对的，客户端使用<code>UnicastRef</code>。</li>
<li>注册端上层获取的对象是<code>RegistryImpl</code>，而客户端上层获取的是<code>RegistryImpl_Stub</code>。</li>
</ol>
<h2 id="4-客户端—服务端"><a href="#4-客户端—服务端" class="headerlink" title="4. 客户端—服务端"></a>4. 客户端—服务端</h2><p>编写服务端前首先得提供一个接口和一个远程对象。</p>
<p>我自己编写了一个远程调用接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.las.remote;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IRemoteHelloWorld</span> <span class="keyword">extends</span> <span class="title">Remote</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">helloWorld</span><span class="params">(Object word)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个远程对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.las.remote;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.UnicastRemoteObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteHelloWorldImpl</span> <span class="keyword">extends</span> <span class="title">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title">IRemoteHelloWorld</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RemoteHelloWorldImpl</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">helloWorld</span><span class="params">(Object word)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello world..&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;las&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我的客户端代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.las.remote.IRemoteHelloWorld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RMIServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Registry registry = LocateRegistry.getRegistry(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">1099</span>);</span><br><span class="line">        IRemoteHelloWorld helloWorld = (IRemoteHelloWorld) registry.lookup(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        helloWorld.helloWorld(<span class="string">&quot;las&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在分析客户端和服务端之前，我想先贴出两者之间产生的流量。</p>
<p><img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201208153851243.png" alt="image-20201208153851243"></p>
<p>红框框住的地方，是客户端在调用远程方法间隙，执行的有关<code>DGC</code>的操作。同时也可以看到，客户端发送的数据包有些太多了。除去握手包，注意第24和26两个包，根本不是我自己发的（远程调用的数据包是32、34号）而且数据量比较大。通过将24、26的数据反序列化后会发现，它们也是和<code>DGC</code>有关的。</p>
<p>关于DGC，简单提一下，全称是<code>distribute garbage collection</code>。其实它的存在也很合理，当客户端获取远程对象时，服务端需要创建一个对象，以供客户端来调用其上的方法；但是这些对象也并不是永久存在的，它们也需要垃圾收集，这就引出了<code>DGC</code>的概念。但是具体是如何实现的我不太清楚，这也是我分析RMI源码的一个原因，希望接下来的分析能让我进一步理解它是如何实现的。</p>
<p>这一次我们先从客户端开始分析。</p>
<p>在此之前，又先抛出另外一个问题。</p>
<h3 id="奇怪的UnicastRemoteObject"><a href="#奇怪的UnicastRemoteObject" class="headerlink" title="奇怪的UnicastRemoteObject"></a>奇怪的UnicastRemoteObject</h3><p>我们知道，一个远程对象，要么得继承<code>UnicastRemoteObject</code>类，要么得通过<code>UnicastRemoteObject#exportObject</code>进行转换：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RMIServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        System.setSecurityManager(<span class="keyword">null</span>);</span><br><span class="line">        IRemoteHelloWorld remoteHelloWorld = <span class="keyword">new</span> RemoteHelloWorldImpl();</span><br><span class="line">        IRemoteHelloWorld remoteHelloWorld2 = <span class="keyword">new</span> RemoteHelloWorldImpl2();</span><br><span class="line">        Object obj2 = UnicastRemoteObject.exportObject(remoteHelloWorld2,<span class="number">0</span>);</span><br><span class="line">        System.out.println(remoteHelloWorld);</span><br><span class="line">        System.out.println(obj2);</span><br><span class="line">        Registry registry = LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">        registry.bind(<span class="string">&quot;Hello&quot;</span>, remoteHelloWorld);</span><br><span class="line">        registry.bind(<span class="string">&quot;Hello2&quot;</span>, (Remote) obj2);</span><br><span class="line">        System.out.println(<span class="string">&quot;[*] RMI Server started...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们将两个对象都打印出来看看：</p>
<p><img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201208163214321.png" alt="image-20201208163214321"></p>
<p>后者是一个代理对象，前者还是正常的<code>RemoteHelloWorldImpl</code>。</p>
<p>但是在客户端看看呢：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RMIClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Registry registry = LocateRegistry.getRegistry(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">1099</span>);</span><br><span class="line">        IRemoteHelloWorld helloWorld = (IRemoteHelloWorld) registry.lookup(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        IRemoteHelloWorld helloWorld2 = (IRemoteHelloWorld) registry.lookup(<span class="string">&quot;Hello2&quot;</span>);</span><br><span class="line">        System.out.println(helloWorld);</span><br><span class="line">        System.out.println(helloWorld2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<p><img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201208163323721.png" alt="image-20201208163323721"></p>
<p>都是代理对象！</p>
<p>这就奇怪了，在分析<strong>客户端—注册端</strong>时，我们讨论了在调用<code>registry.bind</code>时只是单纯将对象放到<code>registryImpl</code>的成员变量<code>bindings</code>中：</p>
<p><img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201208093758689.png" alt="image-20201208093758689"></p>
<p>在客户端<code>lookup</code>时，注册端也只是从这个<code>bindings</code>里将对象取出，并调用<code>writeObject</code>：</p>
<img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201208152016264.png" alt="image-20201208152016264" style="zoom:67%;" />

<img src="C:\Users\47894\AppData\Roaming\Typora\typora-user-images\image-20201208164428005.png" alt="image-20201208164428005" style="zoom:67%;" />

<p>所以问题只可能出在<code>writeObject</code>方法中。</p>
<p>我们跟进<code>var9.writeObject</code>方法，在下面这个地方发现了敏感的函数<code>replaceObject</code>，在进入前我们是<code>RemoteHelloWorldImpl</code>，出来时就是代理对象了：</p>
<img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201208164911643.png" alt="image-20201208164911643" style="zoom:67%;" />

<img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201208171952040.png" alt="image-20201208171952040" style="zoom:67%;" />

<p>此时的调用堆栈：</p>
<img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201208164633241.png" alt="image-20201208164633241" style="zoom:67%;" />

<p>进入<code>MarshalOutputStream#replaceObject</code>瞧瞧：</p>
<p><img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201208164957043.png" alt="image-20201208164957043"></p>
<p>这里的<code>ObjectTable</code>看着怪熟悉的。它在哪个地方似乎出现过。</p>
<p>其实是在<code>TCPTransport#exportObject</code>中：</p>
<img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201207164801827.png" alt="image-20201207164801827" style="zoom:80%;" />

<p>我们之前只跟进了<code>this.listen()</code>，但是在它下面的<code>super.exportObject(var1)</code>里：</p>
<img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201208165747395.png" alt="image-20201208165747395" style="zoom:67%;" />

<p>这里！它将Target放到了<code>ObjectTable</code>中。</p>
<p>但是到目前为止，我还有两个疑问：</p>
<ul>
<li>服务端在什么时候进入了<code>TCPTransport#exportObject</code>，然后将这个<code>Target</code>放到了<code>objectTable</code>里呢？</li>
<li>在<code>replaceObject</code>中，调用<code>Target</code>上的<code>getStub</code>方法获取到的对象和我们在服务端自定义的<code>RemoteHelloWorldImpl</code>有什么关系呢？</li>
</ul>
<p>由于我们的对象<code>RemoteHelloWorldImpl</code>继承了<code>UnicastRemoteObject</code>类，第一时间想到的就是它的构造函数。我猜测也许是在新建<code>RemoteHelloWorldImpl</code>时，调用的父类无参构造函数做了些事情：</p>
<img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201208170312118.png" alt="image-20201208170312118" style="zoom:50%;" />

<p>跟进：</p>
<img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201208170329838.png" alt="image-20201208170329838" style="zoom:50%;" />

<p>发现它竟然调用了<code>exportObject</code>这个静态方法。它是我们创建一个远程对象的第二种方式。继续跟进：</p>
<img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201208170725246.png" alt="image-20201208170725246" style="zoom:50%;" />

<p>跟进ㄟ( ▔, ▔ )ㄏ：</p>
<img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201208171450714.png" alt="image-20201208171450714" style="zoom:50%;" />

<p>终于到头了。</p>
<p>这里得到了两个信息：</p>
<ul>
<li>首先，两种导出远程对象的形式最终都会去执行<code>UnicastServerRef#exportObject</code>。</li>
<li>其次，采用<code>UnicastRemoteObject.export(obj, port)</code>获取的远程对象，其实就是<code>UnicastServerRef#exportObject</code>的返回值。</li>
</ul>
<p>而这个方法，我在<strong>客户端—注册端</strong>其实已经分析了。它的返回值就是一个<code>stub</code>，并且在它冗长的调用链中肯定会执行<code>TCPTransport#exportObject</code>方法。这里又再贴一下<code>UnicastServerRef#exportObject</code>方法：</p>
<p><img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201207162916279.png" alt="image-20201207162916279"></p>
<p>至此，之前的第一个问题解决了。第二个问题：<strong>调用<code>Target</code>上的<code>getStub</code>方法获取到的<code>proxy</code>和我们自己的对象<code>RemoteHelloWorldImpl</code>有什么关系呢？</strong></p>
<p>进入<code>Target</code>的构造函数可以看到：</p>
<img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201208172534872.png" alt="image-20201208172534872" style="zoom:67%;" />

<p>而<code>var3</code>就是我们刚刚创建的<code>Stub</code>对象。</p>
<p>？</p>
<p>回到最最最开始，<strong>我们奇怪两种创建远程对象的方式最终在客户端获取到的都是同一种类型的问题</strong>也解决了：</p>
<ul>
<li>使用<code>extends UnicaseRemoteObject</code>的方式，在<code>writeObject</code>的时候，会去获取到相应的<code>Target</code>上的<code>stub</code>对象。</li>
<li>使用<code>UnicastRemoteObject.exportObject(obj,0);</code>的形式，由于它本身返回值就是这个<code>stub</code>，所以会直接被写入。</li>
</ul>
<hr>
<p>此时我仍然疑惑，这个<code>stub</code>对象究竟是哪一个类？</p>
<p>跟进到<code>UnicastServerRef#exportObject</code>中的<code>Util.createProxy()</code>方法：</p>
<img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201208221507451.png" alt="image-20201208221507451" style="zoom:80%;" />

<p>之前获取的stub对象是在上面if代码块中的<code>createStub()</code>，</p>
<p>而这里则是创建了一个<code>RemoteObjectInvocationHandler</code>的代理对象。</p>
<h3 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h3><h4 id="远程方法调用"><a href="#远程方法调用" class="headerlink" title="远程方法调用"></a>远程方法调用</h4><p>经过了上面的分析，我们知道了客户端的调试需要从<code>RemoteObjectInvocationHandler#invoke</code>方法开始：</p>
<img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201208221949464.png" alt="image-20201208221949464" style="zoom:80%;" />

<p>前面几个if都直接跳过，直接进入到<code>invokeRemoteMethod</code>：</p>
<img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201208222045371.png" alt="image-20201208222045371" style="zoom:67%;" />

<p>进入到<code>UnicastRef#invoke</code>方法，这里只贴出较关键的部分：</p>
<img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201208222704753.png" alt="image-20201208222704753" style="zoom:50%;" />

<p><code>new StreamRemoteCall()</code>之前已经跟过一次，就是写入一个版本字节，同时在BLOCK_DATA处写入数据：</p>
<img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201208111238780.png" alt="image-20201208111238780" style="zoom:70%;" />

<p>在for循环下的<code>marshalValue()</code>部分，是将客户端执行方法传入的参数一个个写入到流中：</p>
<p><img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201208223258229.png" alt="image-20201208223258229"></p>
<p>接下来跟进<code>var7.executeCall()</code>，即<code>StreamRemoteCall#executeCall</code>方法：</p>
<p><img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201208223811120.png" alt="image-20201208223811120"></p>
<p>到<code>this.releaseOutputStream();</code>为止，客户端的调用请求被发送出去。接下来的地方又是老样子，读取首字节，然后获取BLOCK_DATA信息，如果没有抛异常则正常返回（见之前的分析）。</p>
<p>紧接着在<code>unmarshalValue()</code>方法中，将服务端执行命令后的返回对象进行了反序列化读取到<code>var50</code>中，并作为了<code>UnicastRef#invoke</code>的返回值。</p>
<h4 id="dgc分析"><a href="#dgc分析" class="headerlink" title="dgc分析"></a>dgc分析</h4><p>等等，是不是什么东西漏了？明明还有DGC这些东西啊。它们的流量似乎在<code>RemoteObjectInvocationHandler#invoke</code>之前就发出了。</p>
<p>调试后发现，有关<code>DGC</code>的那段流量，在客户端执行<code>registry.lookup</code>方法时就发出了：</p>
<p><img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201208230111090.png" alt="image-20201208230111090"></p>
<p>仔细调试后，定位到执行<code>RegistryImpl_Stub#lookup</code>finally块中的代码会发出这些流量：</p>
<img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201208230313662.png" alt="image-20201208230313662" style="zoom:67%;" />

<p>不断跟进，可以来到<code>StreamRemoteCall#releaseInputStream</code>处：</p>
<p><img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201208230446408.png" alt="image-20201208230446408"></p>
<p><code>registerRefs</code>意味注册引用。看名字有点像是在告诉远端的JVM对对象增加引用的意思。</p>
<p>跟进：</p>
<p><img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201208230918468.png" alt="image-20201208230918468"></p>
<p>这里获取到的<code>var5</code>类型是<code>List&lt;LiveRef&gt;</code>。</p>
<p>跟进<code>DGCClient#registerRefs</code>：</p>
<p><img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201208231148953.png" alt="image-20201208231148953"></p>
<p>这里也许有一些难懂，但是参考<a target="_blank" rel="noopener" href="https://github.com/frohoff/jdk8u-jdk/blob/master/src/share/classes/sun/rmi/transport/DGCClient.java">jdk源码的注释</a>则一目了然：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Register the LiveRef instances in the supplied list to participate</span></span><br><span class="line"><span class="comment">    * in distributed garbage collection.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * All of the LiveRefs in the list must be for remote objects at the</span></span><br><span class="line"><span class="comment">    * given endpoint.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerRefs</span><span class="params">(Endpoint ep, List&lt;LiveRef&gt; refs)</span> </span>&#123;</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Look up the given endpoint and register the refs with it.</span></span><br><span class="line"><span class="comment">        * The retrieved entry may get removed from the global endpoint</span></span><br><span class="line"><span class="comment">        * table before EndpointEntry.registerRefs() is able to acquire</span></span><br><span class="line"><span class="comment">        * its lock; in this event, it returns false, and we loop and</span></span><br><span class="line"><span class="comment">        * try again.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       EndpointEntry epEntry;</span><br><span class="line">       <span class="keyword">do</span> &#123;</span><br><span class="line">           epEntry = EndpointEntry.lookup(ep);</span><br><span class="line">       &#125; <span class="keyword">while</span> (!epEntry.registerRefs(refs));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，每一个<code>Endpoint</code>，它可能有不只一个<code>LiveRef</code>，我们要在这个循环中向<code>Endpoint</code>注册所有这些<code>LiveRef</code>。这里，<code>Endpoint</code>就理解为某个主机上监听在某个端口的进程就行了。</p>
<p>接下来跟进<code>epEntry.registerRefs</code>，即<code>DGCClient#registerRefs(List)</code>：</p>
<img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201208232810278.png" alt="image-20201208232810278" style="zoom:67%;" />

<p>跟进<code>DGCClient#makeDirtyCall</code>：</p>
<img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201208233345945.png" alt="image-20201208233345945" style="zoom:67%;" />

<p>跟进<code>DGCImpl_Stub#dirty</code>：</p>
<img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201208233459799.png" alt="image-20201208233459799" style="zoom:67%;" />

<p>可以看到，在这里发送了<code>dgc</code>请求，并且收到服务端的回复是一个<code>java.rmi.dgc.Lease</code>对象。</p>
<blockquote>
<p>并且我们在这里再次看到了“_stub“字眼，再次说明skel和stub的概念不只用于客户端和服务端之间。</p>
</blockquote>
<p>这个<code>Lease</code>对象的作用可见官方注释：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A lease contains a unique VM identifier and a lease duration. A</span></span><br><span class="line"><span class="comment"> * Lease object is used to request and grant leases to remote object</span></span><br><span class="line"><span class="comment"> * references.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>发现它确实有一个成员变量来表示对象的存活时间：</p>
<img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201209233923973.png" alt="image-20201209233923973" style="zoom:50%;" />

<p>回过头来，再看一下<code>DGCClient</code>这个对象上官方的注释：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DGCClient implements the client-side of the RMI distributed garbage</span></span><br><span class="line"><span class="comment"> * collection system.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The external interface to DGCClient is the &quot;registerRefs&quot; method.</span></span><br><span class="line"><span class="comment"> * When a LiveRef to a remote object enters the VM, it needs to be</span></span><br><span class="line"><span class="comment"> * registered with the DGCClient to participate in distributed garbage</span></span><br><span class="line"><span class="comment"> * collection.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * When the first LiveRef to a particular remote object is registered,</span></span><br><span class="line"><span class="comment"> * a &quot;dirty&quot; call is made to the server-side distributed garbage</span></span><br><span class="line"><span class="comment"> * collector for the remote object, which returns a lease guaranteeing</span></span><br><span class="line"><span class="comment"> * that the server-side DGC will not collect the remote object for a</span></span><br><span class="line"><span class="comment"> * certain period of time.  While LiveRef instances to remote objects</span></span><br><span class="line"><span class="comment"> * on a particular server exist, the DGCClient periodically sends more</span></span><br><span class="line"><span class="comment"> * &quot;dirty&quot; calls to renew its lease.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The DGCClient tracks the local reachability of registered LiveRef</span></span><br><span class="line"><span class="comment"> * instances (using phantom references).  When the LiveRef instance</span></span><br><span class="line"><span class="comment"> * for a particular remote object becomes garbage collected locally,</span></span><br><span class="line"><span class="comment"> * a &quot;clean&quot; call is made to the server-side distributed garbage</span></span><br><span class="line"><span class="comment"> * collector, indicating that the server no longer needs to keep the</span></span><br><span class="line"><span class="comment"> * remote object alive for this client.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.rmi.dgc.DGC, sun.rmi.transport.DGCImpl</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>  Ann Wollrath</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>  Peter Jones</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>这里看到，自调用<code>StreamRemoteCall#releaseInputStream</code>中的<code>this.in.RegisterRefs</code>以来，客户端所作的事情，确实是向服务端注册每一个<code>LiveRef</code>，并且获取到服务端返回的Lease，来告诉服务端短时间内不要回收这些对象。至于像注释说的，租约lease到期后需要再次发送<code>dirty call</code>的操作，就不再跟进了。</p>
<h4 id="图示-1"><a href="#图示-1" class="headerlink" title="图示"></a>图示</h4><p>见服务端。</p>
<h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><h4 id="远程方法执行"><a href="#远程方法执行" class="headerlink" title="远程方法执行"></a>远程方法执行</h4><p>我们在<strong>客户端—注册端</strong>一节，调试<code>LocateRegistry#createRegistry</code>时曾跟进了<code>UnicastServerRef#exportObject</code>方法。它的调用栈会在某个地方执行<code>this.listen()</code>方法监听在某个端口接受客户端的请求；</p>
<p>回到<strong>客户端—服务端</strong>，由于前面分析过，创建一个远程对象无论怎样都会调用<code>UnicastRemoteObject#exportObject</code>方法：</p>
<img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201208171450714.png" alt="image-20201208171450714" style="zoom:50%;" />

<p>在这里也调用了<code>UnicastServerRef#exportObject</code>方法。</p>
<p>所以服务端和注册端一样都通过了<code>UnicastServerRef</code>对象来开放服务。这里就不进一步跟进了。</p>
<p>需要强调的是<code>UnicastServerRef#dispatch</code>方法，我前面也提到过：</p>
<p><img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201209200204445.png" alt="image-20201209200204445"></p>
<p>在远程方法调用时，它是不会进入这个if分支的，而是会继续向下执行。</p>
<p>它首先会从返回数据中读取一个数据类型为Long的变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var4 = var39.readLong();</span><br></pre></td></tr></table></figure>

<p>这个long变量其实是客户端想要调用方法的哈希，当在<code>this.hashToMethod_Map</code>获取不到时会报错：</p>
<p><img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201209200559326.png" alt="image-20201209200559326"></p>
<p>在学习使用反序列化攻击rmi服务端时，如果在客户端自己魔改了远程对象的接口方法（比如参数类型原本在服务端是<code>java.lang.String</code>，但在客户端修改为<code>java.lang.Object</code>），此时需要修改这个哈希值才能正常攻击。</p>
<h4 id="dgc服务"><a href="#dgc服务" class="headerlink" title="dgc服务"></a>dgc服务</h4><p>前面知道，客户端通过<code>LocateRegistry#getRegsitry</code>获取到<code>RegistryImpl_stub</code>对象，在执行<code>RegistryImpl_stub#lookup</code>方法时，会去执行<code>unicastRef#done</code>从而发起一次dgc的“dirty”调用。</p>
<p>那么服务端又是在哪个地方处理这个“dirty”调用的呢？</p>
<p>在刚刚讨论的<strong>远程方法执行</strong>里，我们说如果是远程方法调用是不会进入这个分支的；但是当客户端发起dgc调用时，就会进入这里：</p>
<img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201210195428632.png" alt="image-20201210195428632" style="zoom:67%;" />

<p>注意这里的<code>this.skel</code>成员变量是一个<code>DGCImpl_Skel</code>对象了。</p>
<p>我们继续跟进<code>oldDispatch</code>，发现就会来到<code>DGCImpl_Skel#dispatch</code>方法：</p>
<img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201210195834216.png" alt="image-20201210195834216" style="zoom:67%;" />

<p>并且最终会去执行<code>DGCImpl</code>对象上的<code>dirty</code>或者<code>clean</code>方法。</p>
<p>看一下调用栈：</p>
<img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201210195648725.png" alt="image-20201210195648725" style="zoom:57%;" />



<h4 id="图示-2"><a href="#图示-2" class="headerlink" title="图示"></a>图示</h4><img src="https://gitee.com/Lieutenantas/md-pic/raw/master/image-20201210201455779.png" alt="image-20201210201455779" style="zoom:150%;" />





<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul>
<li>dgc流程：<ol>
<li>客户端通过<code>lookup</code>获取到一个对象后，会向服务端发起一次<code>dirty call</code>，以通知服务端短时间内不要回收该对象；</li>
<li>服务端返回给客户端一个<code>lease</code>，该对象告诉了客户端接下来多久的时间内该对象是有效的。如果客户端在时间到期后还需要使用该对象，则需要继续调用<code>dirty call</code>；</li>
<li><code>DGCClient</code>会跟踪每一个<code>liveRef</code>，当他们在客户端已经不再有效后，就会发起<code>clear call</code>告诉服务端可以回收有关对象了。</li>
</ol>
</li>
<li>无论是rmi注册端还是服务端，它们都通过<code>UnicastServerRef#exportObject</code>开启指定端口上的服务，最终都会进入<code>TCPTransport#handleMessages</code>中的循环来监听输入流，并且最后又都会使用<code>UnicastServerRef#dispatch</code>来调用注册端或者服务端的功能。</li>
</ul>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol>
<li><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/7930">针对RMI服务的九重攻击</a></li>
<li><a target="_blank" rel="noopener" href="https://payloads.info/2020/06/21/Java%E5%AE%89%E5%85%A8-RMI-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/">Java安全-RMI-学习总结</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/frohoff/jdk8u-jdk/blob/master/src/share/classes/sun/rmi/transport/DGCClient.java">DGCClient源码</a></li>
</ol>

    </div>
  </article>
  <div class="toc-container">
    
  <div id="toc" class="toc-article">
    <strong class="toc-title">Posts</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%89%8D%E8%A8%80"><span class="toc-text">1. 前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%9B%9E%E9%A1%BE"><span class="toc-text">2. 回顾</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%AE%A2%E6%88%B7%E7%AB%AF%E2%80%94%E6%B3%A8%E5%86%8C%E7%AB%AF"><span class="toc-text">3. 客户端—注册端</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E7%AB%AF"><span class="toc-text">注册端</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E5%89%8D%E7%9A%84%E8%B0%83%E7%94%A8%E9%93%BE"><span class="toc-text">处理网络数据前的调用链</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE"><span class="toc-text">处理网络数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E7%A4%BA"><span class="toc-text">图示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-text">客户端</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#super-ref-newCall"><span class="toc-text">super.ref.newCall()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#super-ref-invoke"><span class="toc-text">super.ref.invoke()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#var6-readObject"><span class="toc-text">var6.readObject()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%AE%A2%E6%88%B7%E7%AB%AF%E2%80%94%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="toc-text">4. 客户端—服务端</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A5%87%E6%80%AA%E7%9A%84UnicastRemoteObject"><span class="toc-text">奇怪的UnicastRemoteObject</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF-1"><span class="toc-text">客户端</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9C%E7%A8%8B%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8"><span class="toc-text">远程方法调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dgc%E5%88%86%E6%9E%90"><span class="toc-text">dgc分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E7%A4%BA-1"><span class="toc-text">图示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="toc-text">服务端</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9C%E7%A8%8B%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C"><span class="toc-text">远程方法执行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dgc%E6%9C%8D%E5%8A%A1"><span class="toc-text">dgc服务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E7%A4%BA-2"><span class="toc-text">图示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="toc-text">参考链接</span></a></li></ol>
  </div>


  </div>
</div>
<div class="copyright">
</div>
<div class="share" style="width: 100%;">
</div>

  
    <div class="post-nav">
      <div class="post-nav-item post-nav-next">
        
          <span>〈 </span>
          <a href="/2020/12/02/weblogic%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/" rel="next" title="weblogic反序列化漏洞复现">
          weblogic反序列化漏洞复现
          </a>
        
      </div>
  
      <div class="post-nav-item post-nav-prev">
          
      </div>
    </div>
  


    </div>

    

  </div>
  <footer class="footer text-center">
    <div id="bottom-inner">
        <a class="bottom-item" href="">首页</a> |
        <a class="bottom-item" href="" target="_blank">主站</a> |
        <a class="bottom-item" href="https://github.com/KevinOfNeu" target="_blank">GitHub</a> |
        <a class="bottom-item" href="https://hexo.io" target="_blank">Powered by hexo</a> |
        <a class="bottom-item" href="https://github.com/KevinOfNeu/hexo-theme-xoxo" target="_blank">Theme xoxo</a>
    </div>
</footer>
  

<script>
  (function(window, document, undefined) {

    var timer = null;

    function returnTop() {
      cancelAnimationFrame(timer);
      timer = requestAnimationFrame(function fn() {
        var oTop = document.body.scrollTop || document.documentElement.scrollTop;
        if (oTop > 0) {
          document.body.scrollTop = document.documentElement.scrollTop = oTop - 50;
          timer = requestAnimationFrame(fn);
        } else {
          cancelAnimationFrame(timer);
        }
      });
    }

    var hearts = [];
    window.requestAnimationFrame = (function() {
      return window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.oRequestAnimationFrame ||
        window.msRequestAnimationFrame ||
        function(callback) {
          setTimeout(callback, 1000 / 60);
        }
    })();
    init();

    function init() {
      css(".heart{z-index:9999;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: absolute;}.heart:after{top: -5px;}.heart:before{left: -5px;}");
      attachEvent();
      gameloop();
      addMenuEvent();
    }

    function gameloop() {
      for (var i = 0; i < hearts.length; i++) {
        if (hearts[i].alpha <= 0) {
          document.body.removeChild(hearts[i].el);
          hearts.splice(i, 1);
          continue;
        }
        hearts[i].y--;
        hearts[i].scale += 0.004;
        hearts[i].alpha -= 0.013;
        hearts[i].el.style.cssText = "left:" + hearts[i].x + "px;top:" + hearts[i].y + "px;opacity:" + hearts[i].alpha + ";transform:scale(" + hearts[i].scale + "," + hearts[i].scale + ") rotate(45deg);background:" + hearts[i].color;
      }
      requestAnimationFrame(gameloop);
    }

    /**
     * 给logo设置点击事件
     * 
     * - 回到顶部
     * - 出现爱心
     */
    function attachEvent() {
      var old = typeof window.onclick === "function" && window.onclick;
      var logo = document.getElementById("logo");
      if (logo) {
        logo.onclick = function(event) {
          returnTop();
          old && old();
          createHeart(event);
        }
      }
      
    }

    function createHeart(event) {
      var d = document.createElement("div");
      d.className = "heart";
      hearts.push({
        el: d,
        x: event.clientX - 5,
        y: event.clientY - 5,
        scale: 1,
        alpha: 1,
        color: randomColor()
      });
      document.body.appendChild(d);
    }

    function css(css) {
      var style = document.createElement("style");
      style.type = "text/css";
      try {
        style.appendChild(document.createTextNode(css));
      } catch (ex) {
        style.styleSheet.cssText = css;
      }
      document.getElementsByTagName('head')[0].appendChild(style);
    }

    function randomColor() {
      // return "rgb(" + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + ")";
      return "#F44336";
    }

    function addMenuEvent() {
      var menu = document.getElementById('menu-main-post');
      if (menu) {
        var toc = document.getElementById('toc');
        if (toc) {
          menu.onclick = function() {
            if (toc) {
              if (toc.style.display == 'block') {
                toc.style.display = 'none';
              } else {
                toc.style.display = 'block';
              }
            }
          };
        } else {
          menu.style.display = 'none';
        }
      }
    }

  })(window, document);
</script>

  



</body>
</html>
